import pymc3 as pm
import numpy as np
import matplotlib.pyplot as plt
import sys
import pandas
from scipy.stats import kde

"""

    Checking the Uncertainty generated by Arrhenius Fitting

    Program Arguments:
        - iLevel:          Initial Level/Bin for Process' Rates; if it is passed equal to zero, data hard-coded in the file will be read;
        - jLevel:          Final   Level/Bin for Process' Rates; if it is equal to zero, dissociation is considered;
        - PathToRatesFldr: Path to the Folder containing the Rates;
        - TPoints:         Vector of Temperatures for which to read Rates and Rates' SD;
        - TPointsChecK:    Vector of Temperatures for which to compute Posterior Dist.s.

    Example of Program Call:
        python3 StochFitArrhenius.py 100 50 ../run_O3_ALL/Test/O3/O2/Rates/ 3000.0,6000.0,8000.0,10000.0,12000.0,14000.0 1500.0,20000.0

"""

NCores      = 2
MinLinSpace = 1.e3
MaxLinSpace = 20.e3
NLinSpace   = 100
NSamples    = 300
PlotShowFlg = True

iLevel  = int(sys.argv[1])
print("Initial Level = ", iLevel)

if (iLevel==0):
    jLevel          = int(sys.argv[3])
    PathToRatesFldr = sys.argv[3]
    print("Path to Rates Folder = ", PathToRatesFldr)
    TPoints         = sys.argv[4].split(',')
    TCheck          = sys.argv[5].split(',')
    KPoints         = []
    KPointsSD       = []
    for iT in TPoints:
        PathToRatesAtT = PathToRatesFldr + '/T_' + str(int(iT)) + '_' + str(int(iT)) + '/Bin' + str(iLevel) + '.dat'
        xxData = pandas.read_csv(PathToRatesAtT, header=None, skiprows=5, delim_whitespace=True)
        Length = int(xxData.size/4)
        for iiProc in range(Length):
            iProc = int(xxData[1][iiProc])
            K     = float(xxData[2][iiProc].replace('D', 'E'))
            KSD   = float(xxData[3][iiProc].replace('D', 'E'))
            if (iProc == jLevel+1):
                break
        KPoints.append(K)
        KPointsSD.append(KSD)
else:
    iLevel    = 100
    jLevel    = 50
    TPoints   = [          3000.0,           6000.0,           8000.0,          10000.0,          12000.0,          14000.0]
    KPoints   = [0.1902171448e-12, 0.4093877983e-12, 0.6304663150e-12, 0.9151349744e-12, 0.1124105549e-11, 0.1306145213e-11]
    KPointsSD = [0.3235679332e-13, 0.7132421352e-13, 0.5059276285e-13, 0.1641366849e-12, 0.2232497609e-12, 0.2486873826e-12] 
    TCheck    = [1500.0, 20000.0]

print("Final Level = ", jLevel)

TPoints = np.asarray(TPoints, dtype=np.float64)
print("Temperature Data Vector = ", TPoints)

TCheck = np.asarray(TCheck, dtype=np.float64)
print("Temperature Check Vector = ", TPoints)

KPoints      = np.asarray(KPoints,   dtype=np.float64)
KPointsLog   = np.log(KPoints)
KPointsSD    = np.asarray(KPointsSD, dtype=np.float64)
print("Rate    Data Vector = ", KPoints)
print("Rate SD Data Vector = ", KPointsSD)


KPointsError = 2.0*KPointsSD
fig, ax = plt.subplots(figsize=(15, 8))
ax.errorbar(TPoints, KPoints, yerr=KPointsError, c='blue', fmt='o', label="Rate Uncertainties from QCT")
ax.set_yscale('log')
plt.legend();
if (PlotShowFlg):
    plt.show()
else:
    FigPath = './ArrFit_DataPoints.png.' + str(iLevel) + '.' + str(jLevel)
    fig.savefig(FigPath)

# KPointsLog = np.log10(KPoints)
# StochArr = pm.Model()
# with StochArr:
#     KPointsNoisy    = np.random
#     KPointsNoisyLog = np.random
#     a = pm.Uniform('a', -100.0, 0.0, testval=-10.0)
#     b = pm.Uniform('b',    0.0, 1.0, testval=0.5)
#     c = pm.Uniform('c',  1.e1, 1.e6, testval=5.e3) 
#     #KPointsNoisy    = pm.rnormal(mu=KPoints, sd=KPointsSD)
#     #KPointsNoisyLog = np.log(KPointsNoisy)
#     MinForSigma     = KPointsSD
#     MaxForSigma     = 1.e-12*np.array([1.0,1.0,1.0,1.0,1.0,1.0])
#     logK            = pm.Deterministic('logK',      a + b*np.log10(TPoints) - c/TPoints)
#     logKCheck       = pm.Deterministic('logKCheck', 10.0**(a + b*np.log10(TCheck)  - c/TCheck) )
#     #Sigma           = pm.Lognormal('Sigma', mu=0.01, sd=2.0, shape=6, testval=1.e-1)
#     Sigma           = pm.Uniform('Sigma', MinForSigma, MaxForSigma, shape=6, testval=5.e-13)
#     yLike           = pm.Normal('yLike',  mu=10.0**logK, sd=Sigma, observed=KPoints)

# StochArr = pm.Model()
# with StochArr:
#     TVec = np.linspace(MinLinSpace, MaxLinSpace, num=NLinSpace)
#     a = pm.Uniform('a',  -40.0, 0.0, testval=-20.0)
#     b = pm.Uniform('b',    0.0, 1.0, testval=0.5)
#     c = pm.Uniform('c',   0.0 ,20.0, testval=10.0) 
#     logK            = pm.Deterministic('logK',      a + b*np.log(TPoints) - np.exp(c)/TPoints)
#     logKCheck       = pm.Deterministic('logKCheck', a + b*np.log(TCheck)  - np.exp(c)/TCheck )
#     KLinSpace       = pm.Deterministic('KLinSpace', np.exp( a + b*np.log(TCheck)  - np.exp(c)/TCheck ) )
#     Sigma           = pm.Lognormal('Sigma', mu=0.01, sd=3.0,   shape=6, testval=1.e-1)
#     yLike           = pm.Normal('yLike',    mu=logK, sd=Sigma, observed=KPointsLog)


StochArr = pm.Model()
with StochArr:
    TVec = np.linspace(MinLinSpace, MaxLinSpace, num=NLinSpace)
    a = pm.Uniform('a',  -80.0, 0.0, testval=-20.0)
    b = pm.Uniform('b',    0.0, 2.0, testval=0.5)
    c = pm.Uniform('c',   0.0 ,20.0, testval=10.0) 
    logK            = pm.Deterministic('logK',                       a + b*np.log(TPoints) - np.exp(c)/TPoints)
    logKCheck       = pm.Deterministic('logKCheck', np.log10(np.exp( a + b*np.log(TCheck)  - np.exp(c)/TCheck )))
    KLinSpace       = pm.Deterministic('KLinSpace',          np.exp( a + b*np.log(TVec)    - np.exp(c)/TVec ) )
    Sigma           = pm.Lognormal('Sigma', mu=0.01, sd=3.0, testval=1.e-1)
    yLike           = pm.Normal('yLike',    mu=logK, sd=Sigma, observed=KPointsLog)



with StochArr:
    #map_estimate = pm.sample(5000, model=StochArr, tune=5000, cores=8)
    #map_estimate = pm.find_MAP(model=StochArr)
    trace = pm.sample(200000, step=pm.Metropolis(), tune=10000, cores=NCores)
    #trace = pm.sample(5000, step=pm.NUTS(), tune=1000, cores=NCores)


with StochArr:
    pm.traceplot(trace,varnames=['a','b','c','Sigma','logKCheck']);
    #pm.traceplot(trace, figsize=(12, len(trace.varnames)*1.5), lines={k: v for v in a})    
    #pm.summary(trace).round(2)
    plt.show()


PostSamp = pm.sample_posterior_predictive(trace, samples=NSamples, model=StochArr, vars=[KLinSpace])
PostSamp = np.array(list(PostSamp.values())).astype(float)
with StochArr:
    fig, ax = plt.subplots(figsize=(15, 8))
    for i in range(NSamples):
        ax.semilogy(TVec, PostSamp[0,i,:], c='red', alpha=0.1)
    aMean = trace['a'].mean()
    bMean = trace['b'].mean()
    cMean = trace['c'].mean()
    KVec  = np.exp( aMean + bMean*np.log(TVec) - np.exp(cMean)/TVec )
    ax.semilogy(TVec, KVec, c='blue', label="Posterior Mean");
    ax.scatter(TPoints,KPoints , c='blue', edgecolors='none', label="Rate Excpected Values from QCT")
    ax.set_yscale('log')
    ax.errorbar(TPoints, KPoints, yerr=KPointsError, c='blue', fmt='o', label="Rate Uncertainties from QCT")
    ax.set_yscale('log')
    plt.legend();
    if (PlotShowFlg):
        plt.show()
    else:
        FigPath = './ArrFit_KPosteriorSamples.png.' + str(iLevel) + '.' + str(jLevel)
        fig.savefig(FigPath)


pm.plot_posterior(trace, varnames=['logKCheck']);
#pm.plots.densityplot(trace, varnames=['logKCheck'])
if (PlotShowFlg):
    plt.show()
else:
    FigPath = './ArrFit_KPosterior_Check@Ts.png.' + str(iLevel) + '.' + str(jLevel)
    fig.savefig(FigPath)


nbins    = 500
PostSamp = np.ndarray.flatten(PostSamp)
TVec     = np.linspace(MinLinSpace, MaxLinSpace, num=NLinSpace)
TVec     = np.expand_dims(TVec, axis=0)
TMat     = np.repeat(TVec, NSamples, axis=0)
TMat     = np.ndarray.flatten(TMat)
k = kde.gaussian_kde([TMat,PostSamp])
xi, yi = np.mgrid[TMat.min():TMat.max():nbins*1j, PostSamp.min():PostSamp.max():nbins*1j]
zi = k(np.vstack([xi.flatten(), yi.flatten()]))
fig, ax = plt.subplots(figsize=(15, 8))
plt.pcolormesh(xi, yi, zi.reshape(xi.shape))
ax.errorbar(TPoints, KPoints, yerr=KPointsError, c='red', fmt='o', label="Rate Uncertainties from QCT")
ax.scatter( TPoints, KPoints ,                   c='red', edgecolors='none')
ax.set_yscale('log')
plt.legend();
if (PlotShowFlg):
    plt.show()
else:
    FigPath = './ArrFit_KPosteriorDensity.png.' + str(iLevel) + '.' + str(jLevel)
    fig.savefig(FigPath)